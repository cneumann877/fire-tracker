# docker-compose.yml - Fire Department Tracker Enterprise Deployment

version: '3.8'

services:
  fire-tracker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: fire-tracker-app
    restart: unless-stopped
    ports:
      - "${PORT:-3000}:3000"
    environment:
      - NODE_ENV=${NODE_ENV:-production}
      - PORT=3000
      - DATABASE_PATH=/app/data/fire_tracker.db
      - MAX_FAILED_ATTEMPTS=${MAX_FAILED_ATTEMPTS:-5}
      - SESSION_TIMEOUT=${SESSION_TIMEOUT:-480}
      - BACKUP_RETENTION_DAYS=${BACKUP_RETENTION_DAYS:-90}
    volumes:
      - fire_tracker_data:/app/data
      - fire_tracker_logs:/app/logs
      - fire_tracker_backups:/app/backups
      - fire_tracker_exports:/app/exports
    networks:
      - fire_tracker_network
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:3000/api/health', (res) => process.exit(res.statusCode === 200 ? 0 : 1))"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # Optional: Nginx reverse proxy for production
  nginx:
    image: nginx:alpine
    container_name: fire-tracker-nginx
    restart: unless-stopped
    ports:
      - "${HTTP_PORT:-80}:80"
      - "${HTTPS_PORT:-443}:443"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ./ssl:/etc/nginx/ssl:ro  # SSL certificates if using HTTPS
    depends_on:
      - fire-tracker
    networks:
      - fire_tracker_network
    profiles:
      - production
      - nginx

  # Optional: Database backup service
  backup-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: fire-tracker-backup
    restart: no
    environment:
      - NODE_ENV=production
    volumes:
      - fire_tracker_data:/app/data
      - fire_tracker_backups:/app/backups
    networks:
      - fire_tracker_network
    command: node scripts/backup-database.js create
    profiles:
      - backup

volumes:
  fire_tracker_data:
    name: fire_tracker_data
  fire_tracker_logs:
    name: fire_tracker_logs
  fire_tracker_backups:
    name: fire_tracker_backups
  fire_tracker_exports:
    name: fire_tracker_exports

networks:
  fire_tracker_network:
    name: fire_tracker_network
    driver: bridge

---
# docker-compose.dev.yml - Development Environment

version: '3.8'

services:
  fire-tracker-dev:
    build:
      context: .
      dockerfile: Dockerfile
      target: builder
    container_name: fire-tracker-dev
    restart: unless-stopped
    ports:
      - "3000:3000"
      - "9229:9229"  # Node.js debugging port
    environment:
      - NODE_ENV=development
      - PORT=3000
    volumes:
      - .:/app
      - /app/node_modules
      - fire_tracker_dev_data:/app/data
    networks:
      - fire_tracker_dev_network
    command: npm run dev

volumes:
  fire_tracker_dev_data:

networks:
  fire_tracker_dev_network:

---
# .env.example - Environment Variables Template

# Server Configuration
PORT=3000
NODE_ENV=production

# Database Configuration
DATABASE_PATH=./fire_tracker.db

# Security Settings
MAX_FAILED_ATTEMPTS=5
ACCOUNT_LOCKOUT_DURATION=30
SESSION_TIMEOUT=480

# Backup Configuration
BACKUP_RETENTION_DAYS=90
AUTO_BACKUP_ENABLED=true
AUTO_BACKUP_INTERVAL=daily

# Email Configuration (if notifications enabled)
SMTP_HOST=smtp.yourdomain.com
SMTP_PORT=587
SMTP_USER=notifications@yourdepartment.gov
SMTP_PASS=your_email_password

# Department Configuration
DEPARTMENT_NAME=Elk River Fire Department
DEPARTMENT_LOGO=/assets/logo.png
TIMEZONE=America/Chicago

# External Integration
PAYROLL_EXPORT_ENABLED=true
PAYROLL_EXPORT_FORMAT=csv

# Logging Configuration
LOG_LEVEL=info
LOG_RETENTION_DAYS=30

# SSL/TLS (for production)
SSL_ENABLED=false
SSL_CERT_PATH=/path/to/cert.pem
SSL_KEY_PATH=/path/to/key.pem

---
# nginx.conf - Nginx Configuration for Production

server {
    listen 80;
    server_name yourdepartment.local;

    # Redirect HTTP to HTTPS (uncomment for SSL)
    # return 301 https://$server_name$request_uri;

    # HTTP Configuration (remove if using SSL only)
    location / {
        proxy_pass http://fire-tracker:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; font-src 'self' https://cdnjs.cloudflare.com;" always;
    }

    # Static file serving with caching
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        proxy_pass http://fire-tracker:3000;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Security: Block access to sensitive files
    location ~ /\.(ht|env) {
        deny all;
    }
    
    location ~ /(logs|backups|exports)/ {
        deny all;
    }
}

# HTTPS Configuration (uncomment and configure for SSL)
# server {
#     listen 443 ssl http2;
#     server_name yourdepartment.local;
# 
#     ssl_certificate /etc/nginx/ssl/cert.pem;
#     ssl_certificate_key /etc/nginx/ssl/key.pem;
#     ssl_protocols TLSv1.2 TLSv1.3;
#     ssl_ciphers HIGH:!aNULL:!MD5;
# 
#     location / {
#         proxy_pass http://fire-tracker:3000;
#         proxy_http_version 1.1;
#         proxy_set_header Upgrade $http_upgrade;
#         proxy_set_header Connection 'upgrade';
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#         proxy_cache_bypass $http_upgrade;
#     }
# }
